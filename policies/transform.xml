<!-- Request/Response Transformation Policy -->
<!-- Transforms request and response formats, headers, and bodies -->

<policies>
  <inbound>
    <base />
    
    <!-- Example 1: Add/modify request headers -->
    <set-header name="X-Request-Id" exists-action="override">
      <value>@(Guid.NewGuid().ToString())</value>
    </set-header>
    <set-header name="X-Forwarded-For" exists-action="append">
      <value>@(context.Request.IpAddress)</value>
    </set-header>
    
    <!-- Example 2: Transform query parameters to headers -->
    <!-- <set-header name="X-Api-Key" exists-action="override">
      <value>@(context.Request.Url.Query.GetValueOrDefault("api_key", ""))</value>
    </set-header>
    <set-query-parameter name="api_key" exists-action="delete" /> -->
    
    <!-- Example 3: JSON to XML transformation -->
    <!-- <choose>
      <when condition="@(context.Request.Body != null && context.Request.Headers.GetValueOrDefault("Content-Type","").Contains("application/json"))">
        <set-body template="liquid">
          <root>
            {% JSONArrayFor item in body %}
              <item>
                <id>{{item.id}}</id>
                <name>{{item.name}}</name>
              </item>
            {% endJSONArrayFor %}
          </root>
        </set-body>
        <set-header name="Content-Type" exists-action="override">
          <value>application/xml</value>
        </set-header>
      </when>
    </choose> -->
    
    <!-- Example 4: Add authentication header from named value -->
    <!-- <set-header name="Authorization" exists-action="override">
      <value>Bearer {{backend-api-key}}</value>
    </set-header> -->
    
    <!-- Example 5: Transform request body (add fields) -->
    <!-- <set-body>@{
      var body = context.Request.Body.As<JObject>(preserveContent: true);
      body["timestamp"] = DateTime.UtcNow;
      body["clientIp"] = context.Request.IpAddress;
      return body.ToString();
    }</set-body> -->
  </inbound>
  
  <backend>
    <!-- Example 6: Change backend URL based on conditions -->
    <!-- <choose>
      <when condition="@(context.Request.Headers.GetValueOrDefault("X-Version","v1") == "v2")">
        <set-backend-service base-url="https://backend-v2.example.com" />
      </when>
      <otherwise>
        <set-backend-service base-url="https://backend-v1.example.com" />
      </otherwise>
    </choose> -->
    
    <base />
  </backend>
  
  <outbound>
    <base />
    
    <!-- Example 7: Transform response (filter fields) -->
    <set-body>@{
      var response = context.Response.Body.As<JObject>(preserveContent: true);
      // Remove sensitive fields
      response.Remove("internal_id");
      response.Remove("secret_key");
      // Add metadata
      response["_metadata"] = new JObject(
        new JProperty("timestamp", DateTime.UtcNow),
        new JProperty("version", "v1")
      );
      return response.ToString();
    }</set-body>
    
    <!-- Example 8: XML to JSON transformation -->
    <!-- <choose>
      <when condition="@(context.Response.Body != null && context.Response.Headers.GetValueOrDefault("Content-Type","").Contains("application/xml"))">
        <xml-to-json kind="direct" apply="always" consider-accept-header="false" />
        <set-header name="Content-Type" exists-action="override">
          <value>application/json</value>
        </set-header>
      </when>
    </choose> -->
    
    <!-- Example 9: Add CORS headers -->
    <cors allow-credentials="true">
      <allowed-origins>
        <origin>https://app.example.com</origin>
        <origin>https://admin.example.com</origin>
      </allowed-origins>
      <allowed-methods>
        <method>GET</method>
        <method>POST</method>
        <method>PUT</method>
        <method>DELETE</method>
      </allowed-methods>
      <allowed-headers>
        <header>Content-Type</header>
        <header>Authorization</header>
      </allowed-headers>
      <expose-headers>
        <header>X-Request-Id</header>
      </expose-headers>
    </cors>
    
    <!-- Example 10: Standardize error responses -->
    <choose>
      <when condition="@(context.Response.StatusCode >= 400)">
        <set-body>@{
          var errorBody = context.Response.Body.As<JObject>(preserveContent: true);
          return new JObject(
            new JProperty("error", new JObject(
              new JProperty("code", context.Response.StatusCode),
              new JProperty("message", errorBody?["message"]?.ToString() ?? context.Response.StatusReason),
              new JProperty("requestId", context.Request.Headers.GetValueOrDefault("X-Request-Id", ""))
            ))
          ).ToString();
        }</set-body>
      </when>
    </choose>
    
    <!-- Example 11: Add custom response headers -->
    <set-header name="X-Response-Time" exists-action="override">
      <value>@(context.Elapsed.TotalMilliseconds.ToString())ms</value>
    </set-header>
    <set-header name="X-Served-By" exists-action="override">
      <value>APIM</value>
    </set-header>
  </outbound>
  
  <on-error>
    <base />
    
    <!-- Standardize error responses -->
    <return-response>
      <set-status code="@(context.LastError.Source == "policy" ? 500 : context.Response.StatusCode)" />
      <set-header name="Content-Type" exists-action="override">
        <value>application/json</value>
      </set-header>
      <set-body>@{
        return new JObject(
          new JProperty("error", new JObject(
            new JProperty("code", context.LastError.Source == "policy" ? "policy_error" : "internal_error"),
            new JProperty("message", context.LastError.Message),
            new JProperty("requestId", context.Request.Headers.GetValueOrDefault("X-Request-Id", ""))
          ))
        ).ToString();
      }</set-body>
    </return-response>
  </on-error>
</policies>

<!--
Liquid Templates for Complex Transformations:
- Use for declarative data transformation
- Supports loops, conditionals, filters
- More readable than C# for simple transformations

Example Liquid Template (JSON to XML):
<set-body template="liquid">
  <customers>
    {% JSONArrayFor customer in body %}
      <customer>
        <id>{{customer.id}}</id>
        <name>{{customer.name | upcase}}</name>
        <email>{{customer.email}}</email>
      </customer>
    {% endJSONArrayFor %}
  </customers>
</set-body>

Common Transformations:
1. Protocol: SOAP ↔ REST
2. Format: JSON ↔ XML
3. Versioning: Transform between API versions
4. Enrichment: Add metadata, timestamps
5. Filtering: Remove sensitive/internal fields
6. Aggregation: Combine multiple backend responses
7. Normalization: Standardize error formats
8. Pagination: Transform pagination models

Best Practices:
- Preserve original body with preserveContent: true if needed later
- Handle null/missing fields gracefully
- Validate transformed data
- Log transformation errors
- Performance: Minimize transformations (they add latency)
- Security: Sanitize and validate transformed data
- Testing: Test edge cases (empty, null, malformed data)

Performance Impact:
- Simple header manipulation: <1ms
- JSON parsing/manipulation: 5-20ms
- Liquid templates: 10-50ms
- Complex transformations: 50-200ms

Testing:
1. Test with various input formats
2. Verify output structure
3. Test error handling (malformed input)
4. Measure latency impact
5. Load test with transformations enabled
-->
